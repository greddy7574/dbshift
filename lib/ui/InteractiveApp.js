const React = require('react');
const { render, Box, useInput, useApp, Spacer, Static } = require('ink');
const { useStdout } = require('ink');
const { useState, useEffect, useCallback } = React;
const package = require('../../package.json');

// Import dialog components
const InitDialog = require('./components/dialogs/InitDialog');
const CreateDialog = require('./components/dialogs/CreateDialog');
const ConfigDialog = require('./components/dialogs/ConfigDialog');
const ConfigInitDialog = require('./components/dialogs/ConfigInitDialog');
const ConfigSetDialog = require('./components/dialogs/ConfigSetDialog');
const Config = require('../core/config');

// Import layout components
const {
    DBShiftLogo,
    WelcomeTips,
    InputBox,
    UserInputBox,
    CommandOutputBox,
    CommandSuggestions
} = require('./components/Layout');

function startInteractiveMode() {
    // Ê£ÄÊü•ÊòØÂê¶ÊîØÊåÅ‰∫§‰∫íÊ®°Âºè
    if (!process.stdin.isTTY) {
        console.log('üöÄ DBShift Interactive Mode');
        console.log('');
        console.log('‚ùå Interactive mode requires a terminal (TTY)');
        console.log('üí° Use CLI mode instead: dbshift -p -- <command>');
        console.log('');
        console.log('Examples:');
        console.log('  dbshift -p -- status');
        console.log('  dbshift -p -- create "test migration"');
        console.log('  dbshift -p -- migrate');
        console.log('');
        console.log('For help: dbshift --help');
        process.exit(1);
    }

    // ÊçïËé∑ÊéßÂà∂Âè∞ËæìÂá∫ÁöÑËæÖÂä©ÂáΩÊï∞
    const captureConsoleOutput = (fn) => {
        const originalLog = console.log;
        const originalError = console.error;
        const outputs = [];

        console.log = (...args) => {
            outputs.push({ type: 'info', content: args.join(' ') });
            originalLog(...args);
        };

        console.error = (...args) => {
            outputs.push({ type: 'error', content: args.join(' ') });
            originalError(...args);
        };

        return new Promise((resolve) => {
            Promise.resolve(fn()).then(() => {
                console.log = originalLog;
                console.error = originalError;
                resolve(outputs);
            }).catch((error) => {
                console.log = originalLog;
                console.error = originalError;
                outputs.push({ type: 'error', content: error.message });
                resolve(outputs);
            });
        });
    };

    // ÂØºÂÖ•ÂëΩ‰ª§Â§ÑÁêÜÂô®
    const initCommand = require('../commands/init');
    const migrateCommand = require('../commands/migrate');
    const statusCommand = require('../commands/status');
    const createCommand = require('../commands/create');
    const historyCommand = require('../commands/history');
    const showConfigCommand = require('../commands/config/index');
    const configInitCommand = require('../commands/config/init');
    const configSetCommand = require('../commands/config/set');
    const testConnectionCommand = require('../commands/test-connection');

    // ËÆæÁΩÆ‰∫§‰∫íÊ®°ÂºèÁéØÂ¢ÉÂèòÈáè
    process.env.DBSHIFT_INTERACTIVE_MODE = 'true';

    // ÊåÅ‰πÖÂåñÂéÜÂè≤ËÆ∞ÂΩïÁÆ°ÁêÜ
    const HISTORY_FILE = '.dbshift_history';
    const MAX_HISTORY_SIZE = 1000; // Â¢ûÂä†ÂéÜÂè≤ËÆ∞ÂΩïÂÆπÈáèÂà∞1000Êù°
    
    const loadHistory = () => {
        try {
            const fs = require('fs');
            const path = require('path');
            const historyPath = path.join(process.cwd(), HISTORY_FILE);
            
            // üîÑ ÊØèÊ¨°ÂêØÂä®Êó∂Ê∏ÖÁ©∫ÂéÜÂè≤ËÆ∞ÂΩïÊñá‰ª∂ÔºåÂºÄÂßãÂÖ®Êñ∞ÁöÑ‰ºöËØù
            if (fs.existsSync(historyPath)) {
                fs.writeFileSync(historyPath, '', 'utf8'); // Ê∏ÖÁ©∫Êñá‰ª∂ÂÜÖÂÆπ
            }
            
            // ËøîÂõûÁ©∫ÁöÑÂéÜÂè≤ËÆ∞ÂΩïÊï∞ÁªÑÔºåÂºÄÂßãÊñ∞‰ºöËØù
            return [];
        } catch (error) {
            // ÂøΩÁï•ÂéÜÂè≤ËÆ∞ÂΩïÂ§ÑÁêÜÈîôËØØÔºåÁªßÁª≠Ê≠£Â∏∏ËøêË°å
        }
        return [];
    };
    
    const saveHistory = (newHistory) => {
        try {
            const fs = require('fs');
            const path = require('path');
            const historyPath = path.join(process.cwd(), HISTORY_FILE);
            
            // ‰øùÊåÅÂÆåÊï¥È°∫Â∫èÔºåÂÖÅËÆ∏ÈáçÂ§çÂëΩ‰ª§ÔºåÂè™ÈôêÂà∂Â§ßÂ∞è
            const limitedHistory = newHistory.slice(-MAX_HISTORY_SIZE); // ‰øùÁïôÊúÄÊñ∞ÁöÑËÆ∞ÂΩï
            
            fs.writeFileSync(historyPath, limitedHistory.join('\n') + '\n', 'utf8');
        } catch (error) {
            // ÂøΩÁï•ÂéÜÂè≤ËÆ∞ÂΩï‰øùÂ≠òÈîôËØØÔºåÁªßÁª≠Ê≠£Â∏∏ËøêË°å
        }
    };

    // ‰∏ªÂ∫îÁî®ÁªÑ‰ª∂ - Âä†ÂÖ• Gemini CLI È£éÊ†ºÁöÑÂ∏ÉÂ±ÄÊéßÂà∂
    const DBShiftApp = () => {
        const [input, setInput] = useState('');
        const [cursorPosition, setCursorPosition] = useState(0); // New state for cursor position
        const [conversations, setConversations] = useState([]);
        const [suggestions, setSuggestions] = useState([]);
        const [selectedSuggestion, setSelectedSuggestion] = useState(0);
        const [scrollOffset, setScrollOffset] = useState(0); // New state for scroll offset
        const VISIBLE_SUGGESTIONS_COUNT = 8; // New constant for visible suggestions
        const [history, setHistory] = useState(() => loadHistory()); // ÂêØÂä®Êó∂Âä†ËΩΩÂéÜÂè≤ËÆ∞ÂΩï
        const [historyIndex, setHistoryIndex] = useState(-1);
        const [isProcessing, setIsProcessing] = useState(false);
        const [showSuggestions, setShowSuggestions] = useState(false);
        // ÂØπËØùÊ°ÜÁä∂ÊÄÅÁÆ°ÁêÜ
        const [showInitDialog, setShowInitDialog] = useState(false);
        const [showCreateDialog, setShowCreateDialog] = useState(false); // New state for CreateDialog
        const [showConfigDialog, setShowConfigDialog] = useState(false); // New state for ConfigDialog
        const [showConfigInitDialog, setShowConfigInitDialog] = useState(false); // New state for ConfigInitDialog
        const [showConfigSetDialog, setShowConfigSetDialog] = useState(false); // New state for ConfigSetDialog

        const { exit } = useApp();
        const { stdout } = useStdout();

        // ÊçïËé∑ÊéßÂà∂Âè∞ËæìÂá∫ÁöÑËæÖÂä©ÂáΩÊï∞ - ÁßªÂà∞ÂâçÈù¢ÈÅøÂÖçÂºïÁî®ÈîôËØØ
        const captureConsoleOutput = useCallback((fn) => {
            const originalLog = console.log;
            const originalError = console.error;
            const outputs = [];

            console.log = (...args) => {
                outputs.push({ type: 'info', content: args.join(' ') });
                // ‰∏çÂÜçË∞ÉÁî® originalLogÔºåÈÅøÂÖçÈáçÂ§çÊòæÁ§∫
            };

            console.error = (...args) => {
                outputs.push({ type: 'error', content: args.join(' ') });
                // ‰∏çÂÜçË∞ÉÁî® originalErrorÔºåÈÅøÂÖçÈáçÂ§çÊòæÁ§∫
            };

            return new Promise((resolve) => {
                Promise.resolve(fn()).then(() => {
                    console.log = originalLog;
                    console.error = originalError;
                    resolve(outputs);
                }).catch((error) => {
                    console.log = originalLog;
                    console.error = originalError;
                    outputs.push({ type: 'error', content: error.message });
                    resolve(outputs);
                });
            });
        }, []);

        // Gemini CLI È£éÊ†ºÔºöÁªàÁ´ØÂ∞∫ÂØ∏Ê£ÄÊµãÂíåÂ∏ÉÂ±ÄÊéßÂà∂
        const terminalHeight = stdout.rows || 24;
        const terminalWidth = stdout.columns || 80;

        // Gemini CLI È£éÊ†ºÔºö‰∏ç‰ΩøÁî®ÂÆöÊó∂Âô®Èó™ÁÉÅÔºå‰æùËµñÁªàÁ´ØÂéüÁîüË°å‰∏∫
        // ÂÖâÊ†áÂßãÁªàÂèØËßÅÔºå‰ΩøÁî® chalk.inverse() ÂàõÂª∫Á®≥ÂÆöÁöÑÂÖâÊ†áÊïàÊûú
        const cursorVisible = true;

        // ÂèØÁî®ÂëΩ‰ª§
        const commands = [
            { command: '/init', description: 'Initialize migration environment' },
            { command: '/migrate', description: 'Run pending migrations' },
            { command: '/status', description: 'Show migration status' },
            { command: '/create', description: 'Create a new migration file' },
            { command: '/history', description: 'Show migration execution history' },
            { command: '/config', description: 'Show current configuration' },
            { command: '/config-init', description: 'Interactive configuration setup' },
            { command: '/config-set', description: 'Set configuration values' },
            { command: '/ping', description: 'Test database connection' },
            { command: '/about', description: 'Show version information' },
            { command: '/help', description: 'Show available commands' },
            { command: '/exit', description: 'Exit interactive mode' }
        ];

        // Ê∑ªÂä†ÂØπËØù
        const addConversation = useCallback((userInput, outputs) => {
            setConversations(prev => [...prev, { userInput, outputs, timestamp: Date.now() }]);
        }, []);

        // ÂØπËØùÊ°ÜÂ§ÑÁêÜÂáΩÊï∞
        const handleInitDialogComplete = useCallback((result) => {
            setShowInitDialog(false);

            let finalOutputs = [];

            if (result.cancelled) {
                finalOutputs = [
                    { type: 'warning', content: '‚ö†Ô∏è Initialization cancelled' },
                    { type: 'info', content: 'Project initialization was cancelled by user.' }
                ];
            } else if (result.useCliMode) {
                finalOutputs = [
                    { type: 'info', content: 'üîÑ Switching to CLI mode for advanced configuration...' },
                    { type: 'success', content: 'Run: dbshift -p -- init' },
                    { type: 'info', content: 'This will provide full interactive experience with all prompts.' }
                ];
            } else {
                // Â§ÑÁêÜÈÖçÁΩÆÊñá‰ª∂ÂàõÂª∫
                try {
                    const fs = require('fs');
                    const { dbConfig, configType } = result;

                    if (!dbConfig) {
                        finalOutputs = [{ type: 'error', content: '‚ùå No database configuration provided' }];
                    } else {
                        if (configType === 'env') {
                            const envContent = `MYSQL_HOST=${dbConfig.host}
MYSQL_PORT=${dbConfig.port}
MYSQL_USERNAME=${dbConfig.username}
MYSQL_PASSWORD=${dbConfig.password}
`;
                            fs.writeFileSync('.env', envContent);
                            finalOutputs = [
                                { type: 'success', content: '‚úÖ Project initialized successfully!' },
                                { type: 'info', content: 'üìÅ Created .env configuration file' },
                                { type: 'info', content: 'üìÅ Created migrations/ directory' },
                                { type: 'info', content: 'Next steps: Create migrations with /create command' }
                            ];
                        } else {
                            const configContent = `module.exports = {
  development: {
    host: '${dbConfig.host}',
    port: ${dbConfig.port},
    user: '${dbConfig.username}',
    password: '${dbConfig.password}',
    database: 'your_database_name'
  },
  production: {
    host: process.env.MYSQL_HOST || '${dbConfig.host}',
    port: process.env.MYSQL_PORT || ${dbConfig.port},
    user: process.env.MYSQL_USERNAME || '${dbConfig.username}',
    password: process.env.MYSQL_PASSWORD || '${dbConfig.password}',
    database: process.env.MYSQL_DATABASE || 'your_database_name'
  }
};
`;
                            fs.writeFileSync('schema.config.js', configContent);
                            finalOutputs = [
                                { type: 'success', content: '‚úÖ Project initialized successfully!' },
                                { type: 'info', content: 'üìÅ Created schema.config.js configuration file' },
                                { type: 'info', content: 'üìÅ Created migrations/ directory' },
                                { type: 'info', content: 'üí° Edit schema.config.js to add your database name' },
                                { type: 'info', content: 'Next steps: Create migrations with /create command' }
                            ];
                        }

                        if (!fs.existsSync('migrations')) {
                            fs.mkdirSync('migrations');
                        }
                    }
                } catch (error) {
                    finalOutputs = [{ type: 'error', content: `‚ùå Error creating configuration: ${error.message}` }];
                }
            }

            // Update the last conversation instead of creating a new one
            setConversations(prev => {
                if (prev.length === 0) return prev;
                const last = prev[prev.length - 1];
                const updatedLast = { ...last, outputs: finalOutputs };
                return [...prev.slice(0, -1), updatedLast];
            });
        }, [setConversations]);

        const handleInitDialogCancel = useCallback(() => {
            setShowInitDialog(false);
            // Update the last conversation with the cancellation message
            setConversations(prev => {
                if (prev.length === 0) return prev;
                const last = prev[prev.length - 1];
                const updatedLast = { ...last, outputs: [{ type: 'info', content: '‚ùå Initialization cancelled' }] };
                return [...prev.slice(0, -1), updatedLast];
            });
        }, [setConversations]);

        // CreateDialog Â§ÑÁêÜÂáΩÊï∞
        const handleCreateDialogComplete = useCallback(async (result) => {
            setShowCreateDialog(false);
            setIsProcessing(false); // Á´ãÂç≥ÈáçÁΩÆÂ§ÑÁêÜÁä∂ÊÄÅ

            let finalOutputs = [];
            if (result.cancelled) {
                finalOutputs = [{ type: 'warning', content: '‚ö†Ô∏è Migration creation cancelled' }];
            } else {
                try {
                    finalOutputs = await captureConsoleOutput(() => createCommand(result.name, { author: result.author, migrationType: result.type }));
                } catch (error) {
                    finalOutputs = [{ type: 'error', content: `‚ùå Error creating migration: ${error.message}` }];
                }
            }
            setConversations(prev => {
                if (prev.length === 0) return prev;
                const last = prev[prev.length - 1];
                const updatedLast = { ...last, outputs: finalOutputs };
                return [...prev.slice(0, -1), updatedLast];
            });
        }, [captureConsoleOutput, setConversations]);

        const handleCreateDialogCancel = useCallback(() => {
            setShowCreateDialog(false);
            setIsProcessing(false); // Á´ãÂç≥ÈáçÁΩÆÂ§ÑÁêÜÁä∂ÊÄÅ
            setConversations(prev => {
                if (prev.length === 0) return prev;
                const last = prev[prev.length - 1];
                const updatedLast = { ...last, outputs: [{ type: 'info', content: '‚ùå Migration creation cancelled' }] };
                return [...prev.slice(0, -1), updatedLast];
            });
        }, [setConversations]);

        // ConfigDialog Â§ÑÁêÜÂáΩÊï∞
        const handleConfigDialogComplete = useCallback(async (result) => {
            setShowConfigDialog(false);
            setIsProcessing(false);

            let finalOutputs = [];
            if (result.cancelled) {
                finalOutputs = [{ type: 'warning', content: '‚ö†Ô∏è Configuration view cancelled' }];
            } else {
                try {
                    finalOutputs = await captureConsoleOutput(() => showConfigCommand({ env: result.environment }));
                } catch (error) {
                    finalOutputs = [{ type: 'error', content: `‚ùå Error loading configuration: ${error.message}` }];
                }
            }
            setConversations(prev => {
                if (prev.length === 0) return prev;
                const last = prev[prev.length - 1];
                const updatedLast = { ...last, outputs: finalOutputs };
                return [...prev.slice(0, -1), updatedLast];
            });
        }, [captureConsoleOutput, setConversations]);

        const handleConfigDialogCancel = useCallback(() => {
            setShowConfigDialog(false);
            setIsProcessing(false);
            setConversations(prev => {
                if (prev.length === 0) return prev;
                const last = prev[prev.length - 1];
                const updatedLast = { ...last, outputs: [{ type: 'info', content: '‚ùå Configuration view cancelled' }] };
                return [...prev.slice(0, -1), updatedLast];
            });
        }, [setConversations]);

        // ConfigInitDialog Â§ÑÁêÜÂáΩÊï∞
        const handleConfigInitDialogComplete = useCallback(async (result) => {
            // üîë Á´ãÂç≥ËÆæÁΩÆÁä∂ÊÄÅÔºåÁ°Æ‰øùÂØπËØùÊ°ÜÈöêËóè
            setShowConfigInitDialog(false);
            setIsProcessing(false);

            let finalOutputs = [];
            if (result.cancelled) {
                finalOutputs = [{ type: 'warning', content: '‚ö†Ô∏è Configuration setup cancelled' }];
            } else {
                // üîë ‰øÆÂ§çÔºöÁõ¥Êé•Âú®ËøôÈáåÂ§ÑÁêÜÈÖçÁΩÆÂàõÂª∫ÔºåÈÅøÂÖçË∞ÉÁî® inquirer
                try {
                    const fs = require('fs');
                    const path = require('path');
                    const { dbConfig, configType } = result;

                    finalOutputs.push({ type: 'info', content: `‚úì Using ${configType === 'env' ? '.env' : 'schema.config.js'} format` });
                    finalOutputs.push({ type: 'info', content: `  Host: ${dbConfig.host}:${dbConfig.port}` });
                    finalOutputs.push({ type: 'info', content: `  User: ${dbConfig.username}` });
                    finalOutputs.push({ type: 'info', content: `  Password: ${dbConfig.password ? '***' : 'N/A'}` });

                    if (configType === 'env') {
                        const envContent = `### MySQL Database Configuration
MYSQL_HOST=${dbConfig.host}
MYSQL_PORT=${dbConfig.port}
MYSQL_USERNAME=${dbConfig.username}
MYSQL_PASSWORD=${dbConfig.password}

# For production deployment, override these with environment variables:
# export MYSQL_HOST=your-prod-host
# export MYSQL_USERNAME=your-prod-user
# export MYSQL_PASSWORD=your-prod-password
`;
                        fs.writeFileSync('.env', envContent);
                        finalOutputs.push({ type: 'success', content: '‚úì Created .env configuration file' });
                        finalOutputs.push({ type: 'info', content: 'üí° For production, use environment variables to override .env values' });
                    } else {
                        const configContent = `module.exports = {
  development: {
    host: '${dbConfig.host}',
    port: ${dbConfig.port},
    user: '${dbConfig.username}',
    password: '${dbConfig.password}'
  },
  
  staging: {
    host: '${dbConfig.host}',
    port: ${dbConfig.port},
    user: '${dbConfig.username}',
    password: '${dbConfig.password}'
  },
  
  production: {
    host: process.env.MYSQL_HOST || '${dbConfig.host}',
    port: process.env.MYSQL_PORT || ${dbConfig.port},
    user: process.env.MYSQL_USERNAME || '${dbConfig.username}',
    password: process.env.MYSQL_PASSWORD || '${dbConfig.password}'
  }
};
`;
                        fs.writeFileSync('schema.config.js', configContent);
                        finalOutputs.push({ type: 'success', content: '‚úì Created schema.config.js configuration file' });
                        finalOutputs.push({ type: 'info', content: 'üí° Use "dbshift migrate -e production" to run with production config' });
                        finalOutputs.push({ type: 'info', content: 'üí° Set environment variables for production: MYSQL_HOST, MYSQL_USERNAME, etc.' });
                    }

                    finalOutputs.push({ type: 'success', content: 'üéâ Database configuration initialized successfully!' });
                } catch (error) {
                    finalOutputs = [{ type: 'error', content: `‚ùå Error creating configuration: ${error.message}` }];
                }
            }
            setConversations(prev => {
                if (prev.length === 0) return prev;
                const last = prev[prev.length - 1];
                const updatedLast = { ...last, outputs: finalOutputs };
                return [...prev.slice(0, -1), updatedLast];
            });
        }, [setConversations]);

        const handleConfigInitDialogCancel = useCallback(() => {
            setShowConfigInitDialog(false);
            setIsProcessing(false);
            setConversations(prev => {
                if (prev.length === 0) return prev;
                const last = prev[prev.length - 1];
                const updatedLast = { ...last, outputs: [{ type: 'info', content: '‚ùå Configuration setup cancelled' }] };
                return [...prev.slice(0, -1), updatedLast];
            });
        }, [setConversations]);

        // ConfigSetDialog Â§ÑÁêÜÂáΩÊï∞
        const handleConfigSetDialogComplete = useCallback(async (result) => {
            setShowConfigSetDialog(false);
            setIsProcessing(false);

            let finalOutputs = [];
            if (result.cancelled) {
                finalOutputs = [{ type: 'warning', content: '‚ö†Ô∏è Configuration update cancelled' }];
            } else {
                // üîë ‰øÆÂ§çÔºöÁõ¥Êé•Âú®ËøôÈáåÂ§ÑÁêÜÈÖçÁΩÆÊõ¥Êñ∞ÔºåÈÅøÂÖçË∞ÉÁî®Â§ñÈÉ®ÂëΩ‰ª§
                try {
                    const fs = require('fs');
                    const path = require('path');
                    
                    const targetEnv = result.environment || 'development';
                    finalOutputs.push({ type: 'info', content: `‚öôÔ∏è Updating database configuration for [${targetEnv}] environment...` });
                    finalOutputs.push({ type: 'info', content: `  Environment: ${targetEnv}` });
                    finalOutputs.push({ type: 'info', content: `  Host: ${result.host}:${result.port}` });
                    finalOutputs.push({ type: 'info', content: `  User: ${result.username}` });
                    finalOutputs.push({ type: 'info', content: `  Password: ${result.password ? '***' : 'N/A'}` });

                    const envPath = path.join(process.cwd(), '.env');
                    const configPath = path.join(process.cwd(), 'schema.config.js');
                    
                    if (fs.existsSync(configPath)) {
                        // Êõ¥Êñ∞ schema.config.js
                        let configContent = {};
                        try {
                            configContent = require(configPath);
                        } catch (error) {
                            configContent = {};
                        }

                        if (!configContent[targetEnv]) {
                            configContent[targetEnv] = {};
                        }

                        configContent[targetEnv].host = result.host;
                        configContent[targetEnv].port = parseInt(result.port);
                        configContent[targetEnv].user = result.username;
                        configContent[targetEnv].password = result.password;

                        // ÁîüÊàêÈÖçÁΩÆÊñá‰ª∂ÂÜÖÂÆπÔºå‰øùÁïôÁé∞ÊúâÁéØÂ¢ÉÈÖçÁΩÆ
                        const generateConfigContent = (config) => {
                            let content = 'module.exports = {\n';
                            
                            // Á°Æ‰øùÂü∫Êú¨ÁéØÂ¢ÉÂ≠òÂú®
                            const environments = ['development', 'staging', 'production'];
                            environments.forEach(env => {
                                if (config[env] || env === targetEnv) {
                                    const envConfig = config[env] || config[targetEnv];
                                    content += `  ${env}: {\n`;
                                    content += `    host: '${envConfig.host}',\n`;
                                    content += `    port: ${envConfig.port},\n`;
                                    content += `    user: '${envConfig.user}',\n`;
                                    if (env === 'production') {
                                        content += `    password: process.env.MYSQL_PASSWORD || '${envConfig.password}'\n`;
                                    } else {
                                        content += `    password: '${envConfig.password}'\n`;
                                    }
                                    content += `  }${env === 'production' ? '' : ','}\n`;
                                }
                            });
                            
                            content += '};\n';
                            return content;
                        };
                        
                        const configFileContent = generateConfigContent(configContent);
                        fs.writeFileSync(configPath, configFileContent);
                        finalOutputs.push({ type: 'success', content: `‚úì Updated schema.config.js for [${targetEnv}] environment` });
                    } else if (fs.existsSync(envPath)) {
                        // Êõ¥Êñ∞ .env Êñá‰ª∂
                        const newEnvContent = `### MySQL Database Configuration
MYSQL_HOST=${result.host}
MYSQL_PORT=${result.port}
MYSQL_USERNAME=${result.username}
MYSQL_PASSWORD=${result.password}

# For production deployment, override these with environment variables:
# export MYSQL_HOST=your-prod-host
# export MYSQL_USERNAME=your-prod-user
# export MYSQL_PASSWORD=your-prod-password
`;
                        fs.writeFileSync(envPath, newEnvContent);
                        finalOutputs.push({ type: 'success', content: '‚úì Updated .env configuration file' });
                    } else {
                        // ÂàõÂª∫Êñ∞ÁöÑ .env Êñá‰ª∂
                        const newEnvContent = `### MySQL Database Configuration
MYSQL_HOST=${result.host}
MYSQL_PORT=${result.port}
MYSQL_USERNAME=${result.username}
MYSQL_PASSWORD=${result.password}

# For production deployment, override these with environment variables:
# export MYSQL_HOST=your-prod-host
# export MYSQL_USERNAME=your-prod-user
# export MYSQL_PASSWORD=your-prod-password
`;
                        fs.writeFileSync(envPath, newEnvContent);
                        finalOutputs.push({ type: 'success', content: '‚úì Created .env configuration file' });
                    }

                    finalOutputs.push({ type: 'success', content: 'üéâ Database configuration updated successfully!' });
                } catch (error) {
                    finalOutputs = [{ type: 'error', content: `‚ùå Error updating configuration: ${error.message}` }];
                }
            }
            setConversations(prev => {
                if (prev.length === 0) return prev;
                const last = prev[prev.length - 1];
                const updatedLast = { ...last, outputs: finalOutputs };
                return [...prev.slice(0, -1), updatedLast];
            });
        }, [captureConsoleOutput, setConversations]);

        const handleConfigSetDialogCancel = useCallback(() => {
            setShowConfigSetDialog(false);
            setIsProcessing(false);
            setConversations(prev => {
                if (prev.length === 0) return prev;
                const last = prev[prev.length - 1];
                const updatedLast = { ...last, outputs: [{ type: 'info', content: '‚ùå Configuration update cancelled' }] };
                return [...prev.slice(0, -1), updatedLast];
            });
        }, [setConversations]);

        const updateSuggestions = useCallback((inputValue) => {
            if (inputValue.startsWith('/')) {
                // ÊñúÊù†ÂëΩ‰ª§Ê®°Âºè - ÊòæÁ§∫‰ª•ËæìÂÖ•ÂºÄÂ§¥ÁöÑÂëΩ‰ª§
                const filtered = commands.filter(cmd =>
                    cmd.command.toLowerCase().startsWith(inputValue.toLowerCase())
                );
                // Âè™ÊúâÂú®ÁúüÊ≠£ÂèòÂåñÊó∂ÊâçÊõ¥Êñ∞Áä∂ÊÄÅ
                setSuggestions(prev => {
                    if (prev.length !== filtered.length ||
                        prev.some((cmd, index) => cmd.command !== filtered[index]?.command)) {
                        return filtered;
                    }
                    return prev;
                });
                setSelectedSuggestion(0);
                setShowSuggestions(filtered.length > 0);
            } else if (inputValue.trim()) {
                // ÊôÆÈÄöÊ®°ÂºèÔºåÂè™ÊòæÁ§∫ÂÆåÂÖ®ÂåπÈÖçÁöÑÂëΩ‰ª§
                const filtered = commands.filter(cmd =>
                    cmd.command.toLowerCase().startsWith(inputValue.toLowerCase())
                );
                setSuggestions(prev => {
                    if (prev.length !== filtered.length ||
                        prev.some((cmd, index) => cmd.command !== filtered[index]?.command)) {
                        return filtered;
                    }
                    return prev;
                });
                setSelectedSuggestion(0);
                setShowSuggestions(filtered.length > 0);
            } else {
                setSuggestions([]);
                setShowSuggestions(false);
            }
        }, []);

        // ÊâßË°åÂëΩ‰ª§
        const executeCommand = useCallback(async (command) => {
            const parts = command.trim().split(' ');
            const cmdWithSlash = parts[0].toLowerCase();
            const cmd = cmdWithSlash.startsWith('/') ? cmdWithSlash.slice(1) : cmdWithSlash;
            const args = parts.slice(1);

            setIsProcessing(true);

            // Ê†ºÂºèÂåñÁî®Êà∑ËæìÂÖ•ÊòæÁ§∫Ôºà‰øùÁïôÊñúÊù†Ôºâ
            const displayCommand = command.startsWith('/') ? command : `/${command}`;

            let outputs = [];

            try {
                switch (cmd) {
                    case 'init':
                        // ÊòæÁ§∫ Init ÂØπËØùÊ°Ü - ÊåâÁÖß Gemini CLI ÊñπÂºèÔºåÂëΩ‰ª§‰øùÁïôÂú®ÂéÜÂè≤‰∏≠
                        setShowInitDialog(true);
                        setIsProcessing(false); // ÈáçÁΩÆÂ§ÑÁêÜÁä∂ÊÄÅÔºåËÆ©ÂØπËØùÊ°ÜÂ§ÑÁêÜËæìÂÖ•
                        outputs = [{ type: 'info', content: 'üöÄ Opening initialization dialog...' }];
                        // ÂØπ‰∫éÂØπËØùÊ°ÜÂëΩ‰ª§ÔºåÂÖàÊ∑ªÂä†ÂØπËØùËÆ∞ÂΩïÂÜçËøîÂõûÔºåÈÅøÂÖçÈáçÂ§çÊ∑ªÂä†
                        addConversation(displayCommand, outputs);
                        return;

                    case 'migrate':
                        const env = args.find(arg => arg.startsWith('--env='))?.split('=')[1] || 'development';
                        outputs = await captureConsoleOutput(() => migrateCommand({ env }));
                        break;

                    case 'status':
                        const statusEnv = args.find(arg => arg.startsWith('--env='))?.split('=')[1] || 'development';
                        outputs = await captureConsoleOutput(() => statusCommand({ env: statusEnv }));
                        break;

                    case 'create':
                        // ÊòæÁ§∫ Create ÂØπËØùÊ°Ü
                        setShowCreateDialog(true);
                        setIsProcessing(false); // ÈáçÁΩÆÂ§ÑÁêÜÁä∂ÊÄÅÔºåËÆ©ÂØπËØùÊ°ÜÂ§ÑÁêÜËæìÂÖ•
                        outputs = [{ type: 'info', content: 'üìù Opening create migration dialog...' }];
                        // ÂØπ‰∫éÂØπËØùÊ°ÜÂëΩ‰ª§ÔºåÂÖàÊ∑ªÂä†ÂØπËØùËÆ∞ÂΩïÂÜçËøîÂõûÔºåÈÅøÂÖçÈáçÂ§çÊ∑ªÂä†
                        addConversation(displayCommand, outputs);
                        return;

                    case 'history':
                        const historyEnv = args.find(arg => arg.startsWith('--env='))?.split('=')[1] || 'development';
                        const authorFilter = args.find(arg => arg.startsWith('--author='))?.split('=')[1];
                        outputs = await captureConsoleOutput(() => historyCommand({ env: historyEnv, author: authorFilter }));
                        break;

                    case 'config':
                        // Ê£ÄÊü•ÊòØÂê¶ÊåáÂÆö‰∫ÜÁéØÂ¢ÉÂèÇÊï∞
                        const configEnv = args.find(arg => arg.startsWith('--env='))?.split('=')[1];
                        if (configEnv) {
                            // Â¶ÇÊûúÊåáÂÆö‰∫ÜÁéØÂ¢ÉÔºåÁõ¥Êé•ÊòæÁ§∫
                            outputs = await captureConsoleOutput(() => showConfigCommand({ env: configEnv }));
                        } else {
                            // Â¶ÇÊûúÊ≤°ÊúâÊåáÂÆöÁéØÂ¢ÉÔºåÊòæÁ§∫ÈÄâÊã©ÂØπËØùÊ°Ü
                            setShowConfigDialog(true);
                            setIsProcessing(false);
                            outputs = [{ type: 'info', content: '‚öôÔ∏è Opening configuration view dialog...' }];
                            addConversation(displayCommand, outputs);
                            return;
                        }
                        break;

                    case 'config-init':
                        // ÊòæÁ§∫ ConfigInit ÂØπËØùÊ°Ü
                        setShowConfigInitDialog(true);
                        setIsProcessing(false); // ÈáçÁΩÆÂ§ÑÁêÜÁä∂ÊÄÅÔºåËÆ©ÂØπËØùÊ°ÜÂ§ÑÁêÜËæìÂÖ•
                        outputs = [{ type: 'info', content: '‚öôÔ∏è Opening configuration setup dialog...' }];
                        // ÂØπ‰∫éÂØπËØùÊ°ÜÂëΩ‰ª§ÔºåÂÖàÊ∑ªÂä†ÂØπËØùËÆ∞ÂΩïÂÜçËøîÂõûÔºåÈÅøÂÖçÈáçÂ§çÊ∑ªÂä†
                        addConversation(displayCommand, outputs);
                        return;

                    case 'config-set':
                        // Ê£ÄÊü•ÊòØÂê¶ÊúâÂëΩ‰ª§Ë°åÂèÇÊï∞
                        const hasCliArgs = args.some(arg => arg.startsWith('--host=') || arg.startsWith('--port=') || arg.startsWith('--user=') || arg.startsWith('--password=') || arg.startsWith('--database='));

                        if (hasCliArgs) {
                            // Â¶ÇÊûúÊúâÂëΩ‰ª§Ë°åÂèÇÊï∞ÔºåÁõ¥Êé•ÊâßË°å configSetCommand
                            const configOptions = {
                                host: args.find(arg => arg.startsWith('--host='))?.split('=')[1],
                                port: args.find(arg => arg.startsWith('--port='))?.split('=')[1],
                                user: args.find(arg => arg.startsWith('--user='))?.split('=')[1],
                                password: args.find(arg => arg.startsWith('--password='))?.split('=')[1],
                                database: args.find(arg => arg.startsWith('--database='))?.split('=')[1],
                                env: args.find(arg => arg.startsWith('--env='))?.split('=')[1] || 'development'
                            };
                            outputs = await captureConsoleOutput(() => configSetCommand(configOptions));
                        } else {
                            // Â¶ÇÊûúÊ≤°ÊúâÂëΩ‰ª§Ë°åÂèÇÊï∞ÔºåÊòæÁ§∫ ConfigSet ÂØπËØùÊ°Ü
                            setShowConfigSetDialog(true);
                            setIsProcessing(false); // ÈáçÁΩÆÂ§ÑÁêÜÁä∂ÊÄÅÔºåËÆ©ÂØπËØùÊ°ÜÂ§ÑÁêÜËæìÂÖ•
                            outputs = [{ type: 'info', content: '‚öôÔ∏è Opening configuration editor dialog...' }];
                            // ÂØπ‰∫éÂØπËØùÊ°ÜÂëΩ‰ª§ÔºåÂÖàÊ∑ªÂä†ÂØπËØùËÆ∞ÂΩïÂÜçËøîÂõûÔºåÈÅøÂÖçÈáçÂ§çÊ∑ªÂä†
                            addConversation(displayCommand, outputs);
                            return;
                        }
                        break;

                    case 'ping':
                        const pingEnv = args.find(arg => arg.startsWith('--env='))?.split('=')[1] || 'development';
                        const pingOptions = {
                            env: pingEnv,
                            host: args.find(arg => arg.startsWith('--host='))?.split('=')[1],
                            port: args.find(arg => arg.startsWith('--port='))?.split('=')[1],
                            user: args.find(arg => arg.startsWith('--user='))?.split('=')[1],
                            password: args.find(arg => arg.startsWith('--password='))?.split('=')[1],
                            database: args.find(arg => arg.startsWith('--database='))?.split('=')[1]
                        };
                        outputs = await captureConsoleOutput(() => testConnectionCommand(pingOptions));
                        break;

                    case 'about':
                        outputs = [
                            { type: 'info', content: 'About DBShift CLI' },
                            { type: 'info', content: '' },
                            { type: 'info', content: 'CLI Version      ' + package.version },
                            { type: 'info', content: 'Database         MySQL' },
                            { type: 'info', content: 'Framework        Node.js' },
                            { type: 'info', content: 'Migration Tool   Flyway-inspired' },
                            { type: 'info', content: 'License          MIT' },
                            { type: 'info', content: 'Author           greddy7574' }
                        ];
                        break;

                    case 'help':
                        outputs = [
                            { type: 'info', content: 'üìã Available Commands:' },
                            ...commands.map(cmd => ({
                                type: 'info',
                                content: `  ${cmd.command.padEnd(15)} ${cmd.description}`
                            }))
                        ];
                        break;

                    case 'exit':
                        outputs = [{ type: 'info', content: 'üëã Goodbye!' }];
                        addConversation(displayCommand, outputs);
                        exit();
                        return;

                    default:
                        outputs = [{ type: 'error', content: `‚ùå Unknown command: ${cmd}. Type 'help' for available commands.` }];
                        break;
                }
            } catch (error) {
                outputs = [{ type: 'error', content: `‚ùå Error executing command: ${error.message}` }];
            } finally {
                setIsProcessing(false);
            }

            // Ê∑ªÂä†ÂØπËØùËÆ∞ÂΩï
            addConversation(displayCommand, outputs);
        }, [addConversation, exit, captureConsoleOutput]);

        // Â§ÑÁêÜÂëΩ‰ª§Êèê‰∫§
        const handleSubmit = useCallback(async (command) => {
            if (!command.trim() || isProcessing) return;

            // Ê∑ªÂä†Âà∞ÂéÜÂè≤ËÆ∞ÂΩïÔºà‰ºöËØùÂÜÖÁ¥ØÁßØÔºåÂÖÅËÆ∏ÈáçÂ§çÔºâ
            setHistory(prev => {
                const updatedHistory = [...prev, command.trim()]; // Áõ¥Êé•Ê∑ªÂä†Âà∞Êú´Â∞æÔºå‰øùÊåÅÂÆåÊï¥È°∫Â∫è
                
                // ÂºÇÊ≠•‰øùÂ≠òÂéÜÂè≤ËÆ∞ÂΩï
                setTimeout(() => saveHistory(updatedHistory), 0);
                
                return updatedHistory.slice(-MAX_HISTORY_SIZE); // ÈôêÂà∂ÂéÜÂè≤ËÆ∞ÂΩïÂ§ßÂ∞è
            });
            setHistoryIndex(-1);

            // Ê∏ÖÁ©∫ËæìÂÖ•ÂíåÂª∫ËÆÆ
            setInput('');
            setSuggestions([]);
            setShowSuggestions(false);

            // ÊâßË°åÂëΩ‰ª§
            await executeCommand(command);
        }, [executeCommand, isProcessing, addConversation]);

        // Âà†Èô§Â≠óÁ¨¶ÁöÑÁ®≥ÂÆöÂõûË∞É - ÂàÜÁ¶ªÁä∂ÊÄÅÊõ¥Êñ∞ÔºåÁ°Æ‰øùÂÖâÊ†á‰ΩçÁΩÆÊ≠£Á°Æ
        const handleDelete = useCallback(() => {
            setInput(prevInput => {
                if (prevInput.length === 0) return prevInput;
                
                // ÈáçÁΩÆÂÖ∂‰ªñÁä∂ÊÄÅ
                setHistoryIndex(-1);
                setShowSuggestions(false);
                setSuggestions([]);
                
                // Âà†Èô§ÊúÄÂêé‰∏Ä‰∏™Â≠óÁ¨¶ÔºàÈÄÄÊ†ºÈîÆË°å‰∏∫Ôºâ
                return prevInput.slice(0, -1);
            });
            
            // ÂàÜÁ¶ªÂÖâÊ†á‰ΩçÁΩÆÊõ¥Êñ∞
            setCursorPosition(prevCursorPos => {
                if (input.length === 0) return 0;
                const validCursorPos = Math.max(0, Math.min(prevCursorPos, input.length));
                return Math.max(0, validCursorPos - 1);
            });
        }, [input.length]);

        // ÈîÆÁõò‰∫ã‰ª∂Â§ÑÁêÜ - Âè™Âú®Ê≤°ÊúâÂØπËØùÊ°ÜÊó∂ÁõëÂê¨
        useInput(useCallback((inputChar, key) => {
            // Â¶ÇÊûúÂØπËØùÊ°ÜÊòæÁ§∫ÔºåÂÆåÂÖ®‰∏çÂ§ÑÁêÜËæìÂÖ•ÔºåËÆ©ÂØπËØùÊ°ÜÂ§ÑÁêÜ
            if (showInitDialog || showCreateDialog || showConfigDialog || showConfigInitDialog || showConfigSetDialog) {
                return;
            }

            if (isProcessing) {
                return;
            }

            if (key.upArrow) {
                // üîë ‰øÆÂ§çÔºö‰ºòÂÖà‰ΩøÁî®ÂéÜÂè≤ËÆ∞ÂΩïÂØºËà™ÔºåÈô§ÈùûÊòéÁ°ÆÂú®Âª∫ËÆÆÊ®°Âºè‰∏ã
                if (history.length > 0 && (!showSuggestions || suggestions.length === 0)) {
                    // ÂéÜÂè≤ÂØºËà™Âêë‰∏ä - ÊîπËøõÁöÑÂéÜÂè≤ËÆ∞ÂΩïÂØºËà™
                    let newIndex;
                    if (historyIndex === -1) {
                        // ‰ªéÊúÄÊñ∞ÁöÑÂéÜÂè≤ËÆ∞ÂΩïÂºÄÂßã
                        newIndex = history.length - 1;
                    } else {
                        // ÂêëÂâçÊü•ÁúãÊõ¥Êó©ÁöÑÂéÜÂè≤ËÆ∞ÂΩï
                        newIndex = Math.max(0, historyIndex - 1);
                    }
                    setHistoryIndex(newIndex);
                    const selectedCommand = history[newIndex];
                    setInput(selectedCommand);
                    setCursorPosition(selectedCommand.length); // ÁßªÂä®ÂÖâÊ†áÂà∞Êú´Â∞æ
                    // Ê∏ÖÈô§Âª∫ËÆÆ‰ª•ÈÅøÂÖçÂπ≤Êâ∞
                    setSuggestions([]);
                    setShowSuggestions(false);
                } else if (showSuggestions && suggestions.length > 0) {
                    // Âú®Âª∫ËÆÆÂàóË°®‰∏≠Âêë‰∏äÂØºËà™
                    setSelectedSuggestion(prev => {
                        const newIndex = prev > 0 ? prev - 1 : suggestions.length - 1;
                        // Ë∞ÉÊï¥ÊªöÂä®ÂÅèÁßªÈáè
                        if (newIndex < scrollOffset) {
                            setScrollOffset(newIndex);
                        } else if (newIndex >= scrollOffset + VISIBLE_SUGGESTIONS_COUNT) {
                            setScrollOffset(newIndex - VISIBLE_SUGGESTIONS_COUNT + 1);
                        }
                        return newIndex;
                    });
                }
            } else if (key.downArrow) {
                // üîë ‰øÆÂ§çÔºö‰ºòÂÖà‰ΩøÁî®ÂéÜÂè≤ËÆ∞ÂΩïÂØºËà™ÔºåÈô§ÈùûÊòéÁ°ÆÂú®Âª∫ËÆÆÊ®°Âºè‰∏ã
                if (historyIndex !== -1 && history.length > 0 && (!showSuggestions || suggestions.length === 0)) {
                    // ÂéÜÂè≤ÂØºËà™Âêë‰∏ã - ÊîπËøõÁöÑÂéÜÂè≤ËÆ∞ÂΩïÂØºËà™
                    const newIndex = historyIndex + 1;
                    if (newIndex < history.length) {
                        // ËøòÊúâÊõ¥Êñ∞ÁöÑÂéÜÂè≤ËÆ∞ÂΩï
                        setHistoryIndex(newIndex);
                        const selectedCommand = history[newIndex];
                        setInput(selectedCommand);
                        setCursorPosition(selectedCommand.length); // ÁßªÂä®ÂÖâÊ†áÂà∞Êú´Â∞æ
                        // Ê∏ÖÈô§Âª∫ËÆÆ‰ª•ÈÅøÂÖçÂπ≤Êâ∞
                        setSuggestions([]);
                        setShowSuggestions(false);
                    } else {
                        // Âà∞ËææÊúÄÊñ∞ÔºåÂõûÂà∞Á©∫ËæìÂÖ•
                        setHistoryIndex(-1);
                        setInput('');
                        setCursorPosition(0); // ÁßªÂä®ÂÖâÊ†áÂà∞ÂºÄÂ§¥
                        setSuggestions([]);
                        setShowSuggestions(false);
                    }
                } else if (showSuggestions && suggestions.length > 0) {
                    // Âú®Âª∫ËÆÆÂàóË°®‰∏≠Âêë‰∏ãÂØºËà™
                    setSelectedSuggestion(prev => {
                        const newIndex = prev < suggestions.length - 1 ? prev + 1 : 0;
                        // Ë∞ÉÊï¥ÊªöÂä®ÂÅèÁßªÈáè
                        if (newIndex >= scrollOffset + VISIBLE_SUGGESTIONS_COUNT) {
                            setScrollOffset(newIndex - VISIBLE_SUGGESTIONS_COUNT + 1);
                        } else if (newIndex < scrollOffset) {
                            setScrollOffset(newIndex);
                        }
                        return newIndex;
                    });
                }
            } else if (key.leftArrow) {
                // Â∑¶ÊñπÂêëÈîÆ
                setCursorPosition(prev => Math.max(0, prev - 1));
            } else if (key.rightArrow) {
                // Âè≥ÊñπÂêëÈîÆ
                setCursorPosition(prev => Math.min(input.length, prev + 1));
            } else if (key.tab) {
                // Tab Ëá™Âä®Ë°•ÂÖ®
                if (suggestions.length > 0) {
                    const selectedCommand = suggestions[selectedSuggestion].command;
                    setInput(selectedCommand);
                    setCursorPosition(selectedCommand.length); // ÁßªÂä®ÂÖâÊ†áÂà∞Êú´Â∞æ
                    updateSuggestions(selectedCommand);
                    // ÈáçÁΩÆÂéÜÂè≤ÂØºËà™
                    setHistoryIndex(-1);
                }
            } else if (key.return) {
                // Êèê‰∫§ÂëΩ‰ª§
                let commandToExecute = input;
                if (showSuggestions && suggestions.length > 0) {
                    // Â¶ÇÊûúÊúâÂª∫ËÆÆÔºåÈÄâÊã©ÂΩìÂâçÂª∫ËÆÆÂπ∂ÊâßË°å
                    commandToExecute = suggestions[selectedSuggestion].command;
                    setInput(commandToExecute);
                    setCursorPosition(commandToExecute.length); // ÁßªÂä®ÂÖâÊ†áÂà∞Êú´Â∞æ
                    setShowSuggestions(false);
                    setSuggestions([]);
                }
                // ÈáçÁΩÆÂéÜÂè≤ÂØºËà™
                setHistoryIndex(-1);
                // Êèê‰∫§ÂëΩ‰ª§
                handleSubmit(commandToExecute);
            } else if (key.escape) {
                // ÈöêËóèÂª∫ËÆÆÔºåÂÖÅËÆ∏ÂéÜÂè≤ÂØºËà™
                setShowSuggestions(false);
                setSuggestions([]);
                // üîë ‰øÆÂ§çÔºöÊåâEscapeÈîÆÊó∂‰∏çÈáçÁΩÆÂéÜÂè≤ÂØºËà™Áä∂ÊÄÅ
                // setHistoryIndex(-1); // ÁßªÈô§ËøôË°åÔºåËÆ©Áî®Êà∑ÂèØ‰ª•Âú®ÂÖ≥Èó≠Âª∫ËÆÆÂêéÁªßÁª≠ÂéÜÂè≤ÂØºËà™
            } else if (key.ctrl && inputChar === 'c') {
                // Ctrl+C ÈÄÄÂá∫
                addConversation('/exit', [{ type: 'info', content: 'üëã Goodbye!' }]);
                exit();
            } else if (key.backspace || key.delete || inputChar === '\u0008' || inputChar === '\u007f') {
                // Âà†Èô§Â≠óÁ¨¶ - ÊîØÊåÅÂ§öÁßçÂà†Èô§ÈîÆÂèò‰ΩìÔºå‰ΩøÁî®Á®≥ÂÆöÁöÑÂõûË∞É
                handleDelete();
            } else if (inputChar && inputChar.length === 1 && !key.ctrl && !key.meta && !key.tab && !key.return && !key.backspace && !key.delete && !key.upArrow && !key.downArrow && !key.leftArrow && !key.rightArrow && !key.escape && inputChar !== '\u0008' && inputChar !== '\u007f') {
                // ÊôÆÈÄöÂ≠óÁ¨¶ËæìÂÖ• - ÊèíÂÖ•Âà∞ÂÖâÊ†á‰ΩçÁΩÆ
                const charCode = inputChar.charCodeAt(0);
                if (charCode >= 32 && charCode <= 126) {
                    // üîë ‰øÆÂ§çÂÖâÊ†á‰ΩçÁΩÆÔºöÁÆÄÂåñÈÄªËæëÔºåÂàÜÁ¶ªÁä∂ÊÄÅÊõ¥Êñ∞
                    setInput(prevInput => {
                        // ËÆ°ÁÆóÊúâÊïàÁöÑÊèíÂÖ•‰ΩçÁΩÆÔºàÈÄöÂ∏∏Âú®Êú´Â∞æÔºâ
                        const insertPos = Math.max(0, Math.min(cursorPosition, prevInput.length));
                        
                        // ÈáçÁΩÆÂÖ∂‰ªñÁä∂ÊÄÅ
                        setHistoryIndex(-1);
                        setShowSuggestions(false);
                        setSuggestions([]);
                        
                        // ÊèíÂÖ•Â≠óÁ¨¶Âà∞ÂΩìÂâçÂÖâÊ†á‰ΩçÁΩÆ
                        return prevInput.slice(0, insertPos) + inputChar + prevInput.slice(insertPos);
                    });
                    
                    // ÂàÜÁ¶ªÂÖâÊ†á‰ΩçÁΩÆÊõ¥Êñ∞ÔºåÁ°Æ‰øù‰∏éËæìÂÖ•ÂêåÊ≠•
                    setCursorPosition(prevCursorPos => {
                        const validPos = Math.max(0, Math.min(prevCursorPos, input.length));
                        return validPos + 1;
                    });
                }
            }
        }, [input, history, historyIndex, suggestions, selectedSuggestion, showSuggestions, handleSubmit, isProcessing, exit, addConversation, updateSuggestions, showInitDialog, showCreateDialog, showConfigDialog, showConfigInitDialog, showConfigSetDialog, cursorPosition, handleDelete]));

        // ÁõëÂê¨ËæìÂÖ•ÂèòÂåñ - ‰ºòÂåñÈò≤ÊäñÁ≠ñÁï•ÔºåÊèêÂçáÂø´ÈÄüËæìÂÖ•Êó∂ÁöÑÂìçÂ∫îÊÄß
        useEffect(() => {
            const timeoutId = setTimeout(() => {
                updateSuggestions(input);
            }, input.length === 0 ? 30 : 80); // Ëøõ‰∏ÄÊ≠•ÂáèÂ∞ëÂª∂ËøüÔºåÊèêÂçáÂìçÂ∫îÊÄß

            return () => clearTimeout(timeoutId);
        }, [input, updateSuggestions]);

        // Ê∏≤ÊüìÁïåÈù¢ - ÂÆåÂÖ®ÊåâÁÖß Gemini CLI ÁöÑÁúüÂÆûÁªìÊûÑÂ§çÂà∂
        return React.createElement(Box, {
                flexDirection: 'column',
                marginBottom: 1,
                width: '90%'
            },
            // Static Âå∫Âüü - ÂØπÂ∫î Gemini CLI ÁöÑÂõ∫ÂÆöÂÜÖÂÆπ
            React.createElement(Static, {
                key: 'staticContent',
                items: [
                    React.createElement(Box, { key: 'header', flexDirection: 'column' },
                        React.createElement(DBShiftLogo),
                        React.createElement(WelcomeTips)
                    )
                ]
            }, (item) => item),

            // OverflowProvider Âå∫Âüü - ÂØπÂ∫î Gemini CLI ÁöÑÊªöÂä®ÂÜÖÂÆπ
            React.createElement(Box, { flexDirection: 'column' },
                conversations.map((conversation, index) =>
                    React.createElement(Box, { key: index, flexDirection: 'column', marginBottom: 1 },
                        React.createElement(UserInputBox, { command: conversation.userInput }),
                        React.createElement(CommandOutputBox, { outputs: conversation.outputs })
                    )
                )
            ),

            // ‰∏ªÊéßÂà∂Âå∫Âüü - ÂÆåÂÖ®ÂØπÂ∫î Gemini CLI ÁöÑ mainControlsRef
            React.createElement(Box, { flexDirection: 'column' },
                // Êù°‰ª∂Ê∏≤Êüì - ÂÆåÂÖ®ÊåâÁÖß Gemini CLI ÁöÑ‰∏âÂÖÉËøêÁÆóÁ¨¶ÁªìÊûÑ
                showInitDialog ? (
                    React.createElement(Box, { flexDirection: 'column' },
                        React.createElement(InitDialog, {
                            isVisible: showInitDialog,
                            onComplete: handleInitDialogComplete,
                            onCancel: handleInitDialogCancel
                        })
                    )
                ) : showCreateDialog ? (
                    React.createElement(Box, { flexDirection: 'column' },
                        React.createElement(CreateDialog, {
                            isVisible: showCreateDialog,
                            onComplete: handleCreateDialogComplete,
                            onCancel: handleCreateDialogCancel
                        })
                    )
                ) : showConfigDialog ? (
                    React.createElement(Box, { flexDirection: 'column' },
                        React.createElement(ConfigDialog, {
                            isVisible: showConfigDialog,
                            onComplete: handleConfigDialogComplete,
                            onCancel: handleConfigDialogCancel
                        })
                    )
                ) : showConfigInitDialog ? (
                    React.createElement(Box, { flexDirection: 'column' },
                        React.createElement(ConfigInitDialog, {
                            isVisible: showConfigInitDialog,
                            onComplete: handleConfigInitDialogComplete,
                            onCancel: handleConfigInitDialogCancel
                        })
                    )
                ) : showConfigSetDialog ? (
                    React.createElement(Box, { flexDirection: 'column' },
                        React.createElement(ConfigSetDialog, {
                            isVisible: showConfigSetDialog,
                            onComplete: handleConfigSetDialogComplete,
                            onCancel: handleConfigSetDialogCancel,
                            initialConfig: {}
                        })
                    )
                ) : (
                    React.createElement(React.Fragment, {},
                        React.createElement(InputBox, {
                            value: input,
                            showCursor: cursorVisible,
                            cursorPosition: cursorPosition
                        }),

                        showSuggestions && React.createElement(CommandSuggestions, {
                            commands: suggestions,
                            selectedIndex: selectedSuggestion,
                            showCount: true,
                            scrollOffset: scrollOffset,
                            visibleCount: VISIBLE_SUGGESTIONS_COUNT
                        })
                    )
                )
            )
        );
    };

    // Ê∏≤ÊüìÂ∫îÁî®
    render(React.createElement(DBShiftApp));
}

module.exports = { startInteractiveMode };